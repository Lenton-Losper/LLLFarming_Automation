/**
 * Message filtering middleware for WhatsApp bot
 * Handles message validation, spam prevention, and owner restrictions
 */

const { OWNER_NUMBER } = require('../config/constants');
const { isToday, getTimeDifferenceInMinutes } = require('../utils/helpers');

/**
 * Filter configuration
 */
const FILTER_CONFIG = {
    MAX_MESSAGE_LENGTH: 1000,
    MIN_MESSAGE_INTERVAL: 2, // seconds
    MAX_MESSAGES_PER_MINUTE: 10,
    BLOCKED_KEYWORDS: ['spam', 'test123', 'promotion'],
    ALLOWED_FILE_TYPES: ['image', 'document'],
    MAX_DAILY_MESSAGES: 100
};

/**
 * Message rate tracking
 */
const messageRates = new Map();
const dailyMessageCounts = new Map();

/**
 * Check if message should be ignored based on sender
 * @param {string} remoteJid - Sender's JID
 * @param {string} pushName - Sender's name
 * @returns {boolean} - True if message should be ignored
 */
function shouldIgnoreOwner(remoteJid, pushName) {
    if (remoteJid === OWNER_NUMBER) {
        console.log('üö´ Ignoring message from owner:', pushName);
        return true;
    }
    return false;
}

/**
 * Check if message is from a group
 * @param {string} remoteJid - Sender's JID
 * @returns {boolean} - True if message is from group
 */
function isGroupMessage(remoteJid) {
    return remoteJid.endsWith('@g.us');
}

/**
 * Check if message is from bot itself
 * @param {Object} messageKey - Message key object
 * @returns {boolean} - True if message is from bot
 */
function isBotMessage(messageKey) {
    return messageKey.fromMe;
}

/**
 * Check if message is too old
 * @param {number} messageTimestamp - Message timestamp
 * @param {number} botStartTime - Bot start time
 * @returns {boolean} - True if message is too old
 */
function isOldMessage(messageTimestamp, botStartTime) {
    const msgTime = (messageTimestamp?.low || messageTimestamp) * 1000;
    
    // Ignore messages sent before bot started
    if (msgTime < botStartTime) {
        return true;
    }
    
    // Ignore messages older than 1 day
    const msgDate = new Date(msgTime);
    if (!isToday(msgDate)) {
        return true;
    }
    
    return false;
}

/**
 * Check if message has valid content
 * @param {Object} message - WhatsApp message object
 * @returns {boolean} - True if message has valid content
 */
function hasValidContent(message) {
    const text = extractMessageText(message);
    
    // Must have text content
    if (!text || text.trim().length === 0) {
        return false;
    }
    
    // Check message length
    if (text.length > FILTER_CONFIG.MAX_MESSAGE_LENGTH) {
        console.log('üö´ Message too long:', text.length);
        return false;
    }
    
    return true;
}

/**
 * Extract text from WhatsApp message
 * @param {Object} message - WhatsApp message object
 * @returns {string} - Extracted text
 */
function extractMessageText(message) {
    return (
        message.conversation ||
        message.extendedTextMessage?.text ||
        message.imageMessage?.caption ||
        message.documentMessage?.caption ||
        ''
    ).trim();
}

/**
 * Check for spam content
 * @param {string} text - Message text
 * @returns {boolean} - True if message contains spam
 */
function containsSpam(text) {
    const lowerText = text.toLowerCase();
    
    // Check for blocked keywords
    for (const keyword of FILTER_CONFIG.BLOCKED_KEYWORDS) {
        if (lowerText.includes(keyword)) {
            console.log('üö´ Spam detected:', keyword);
            return true;
        }
    }
    
    // Check for excessive repetition
    if (hasExcessiveRepetition(text)) {
        console.log('üö´ Excessive repetition detected');
        return true;
    }
    
    // Check for excessive caps
    if (hasExcessiveCaps(text)) {
        console.log('üö´ Excessive caps detected');
        return true;
    }
    
    return false;
}

/**
 * Check for excessive character repetition
 * @param {string} text - Message text
 * @returns {boolean} - True if excessive repetition found
 */
function hasExcessiveRepetition(text) {
    // Check for same character repeated more than 5 times
    const repetitionPattern = /(.)\1{5,}/;
    return repetitionPattern.test(text);
}

/**
 * Check for excessive capital letters
 * @param {string} text - Message text
 * @returns {boolean} - True if excessive caps found
 */
function hasExcessiveCaps(text) {
    if (text.length < 10) return false;
    
    const capsCount = (text.match(/[A-Z]/g) || []).length;
    const capsRatio = capsCount / text.length;
    
    return capsRatio > 0.7; // More than 70% caps
}

/**
 * Check rate limiting for user
 * @param {string} userId - User ID
 * @returns {boolean} - True if rate limited
 */
function isRateLimited(userId) {
    const now = Date.now();
    const userRates = messageRates.get(userId) || [];
    
    // Remove old entries (older than 1 minute)
    const recentMessages = userRates.filter(timestamp => 
        now - timestamp < 60000
    );
    
    // Check if user exceeded rate limit
    if (recentMessages.length >= FILTER_CONFIG.MAX_MESSAGES_PER_MINUTE) {
        console.log('üö´ Rate limit exceeded for user:', userId);
        return true;
    }
    
    // Check minimum interval between messages
    if (recentMessages.length > 0) {
        const lastMessage = Math.max(...recentMessages);
        const timeSinceLastMessage = (now - lastMessage) / 1000;
        
        if (timeSinceLastMessage < FILTER_CONFIG.MIN_MESSAGE_INTERVAL) {
            console.log('üö´ Message interval too short:', timeSinceLastMessage);
            return true;
        }
    }
    
    // Update rate tracking
    recentMessages.push(now);
    messageRates.set(userId, recentMessages);
    
    return false;
}

/**
 * Check daily message limit
 * @param {string} userId - User ID
 * @returns {boolean} - True if daily limit exceeded
 */
function isDailyLimitExceeded(userId) {
    const today = new Date().toDateString();
    const userDailyKey = `${userId}-${today}`;
    
    const dailyCount = dailyMessageCounts.get(userDailyKey) || 0;
    
    if (dailyCount >= FILTER_CONFIG.MAX_DAILY_MESSAGES) {
        console.log('üö´ Daily message limit exceeded for user:', userId);
        return true;
    }
    
    // Increment daily count
    dailyMessageCounts.set(userDailyKey, dailyCount + 1);
    
    return false;
}

/**
 * Check if message is duplicate
 * @param {string} messageId - Message ID
 * @param {Object} ordersCollection - Firebase orders collection
 * @returns {Promise<boolean>} - True if message is duplicate
 */
async function isDuplicateMessage(messageId, ordersCollection) {
    try {
        const existing = await ordersCollection.doc(messageId).get();
        return existing.exists;
    } catch (error) {
        console.error('‚ùå Error checking duplicate message:', error);
        return false;
    }
}

/**
 * Check if file type is allowed
 * @param {Object} message - WhatsApp message object
 * @returns {boolean} - True if file type is allowed
 */
function isAllowedFileType(message) {
    // Check for image messages
    if (message.imageMessage) {
        return FILTER_CONFIG.ALLOWED_FILE_TYPES.includes('image');
    }
    
    // Check for document messages
    if (message.documentMessage) {
        return FILTER_CONFIG.ALLOWED_FILE_TYPES.includes('document');
    }
    
    // Text messages are always allowed
    return true;
}

/**
 * Main filter function to check if message should be processed
 * @param {Object} msg - WhatsApp message object
 * @param {number} botStartTime - Bot start time
 * @param {Object} ordersCollection - Firebase orders collection
 * @returns {Promise<Object>} - Filter result with status and details
 */
async function filterMessage(msg, botStartTime, ordersCollection) {
    const result = {
        shouldProcess: false,
        reason: null,
        messageText: '',
        userId: null,
        messageId: null,
        senderName: null
    };
    
    try {
        // Basic message validation
        if (!msg.message) {
            result.reason = 'No message content';
            return result;
        }
        
        const userId = msg.key.remoteJid;
        const messageId = msg.key.id;
        const senderName = msg.pushName || 'Customer';
        const messageText = extractMessageText(msg.message);
        
        result.userId = userId;
        result.messageId = messageId;
        result.senderName = senderName;
        result.messageText = messageText;
        
        // Check if message is from bot
        if (isBotMessage(msg.key)) {
            result.reason = 'Message from bot';
            return result;
        }
        
        // Check if message is from group
        if (isGroupMessage(userId)) {
            result.reason = 'Group message';
            return result;
        }
        
        // Check if message is from owner
        if (shouldIgnoreOwner(userId, senderName)) {
            result.reason = 'Message from owner';
            return result;
        }
        
        // Check if message is too old
        if (isOldMessage(msg.messageTimestamp, botStartTime)) {
            result.reason = 'Old message';
            return result;
        }
        
        // Check if message has valid content
        if (!hasValidContent(msg.message)) {
            result.reason = 'Invalid content';
            return result;
        }
        
        // Check for spam
        if (containsSpam(messageText)) {
            result.reason = 'Spam detected';
            return result;
        }
        
        // Check rate limiting
        if (isRateLimited(userId)) {
            result.reason = 'Rate limited';
            return result;
        }
        
        // Check daily limit
        if (isDailyLimitExceeded(userId)) {
            result.reason = 'Daily limit exceeded';
            return result;
        }
        
        // Check for duplicate message
        if (await isDuplicateMessage(messageId, ordersCollection)) {
            result.reason = 'Duplicate message';
            return result;
        }
        
        // Check file type
        if (!isAllowedFileType(msg.message)) {
            result.reason = 'Invalid file type';
            return result;
        }
        
        // All checks passed
        result.shouldProcess = true;
        return result;
        
    } catch (error) {
        console.error('‚ùå Error in message filter:', error);
        result.reason = 'Filter error';
        return result;
    }
}

/**
 * Clean up old tracking data
 */
function cleanupOldData() {
    const now = Date.now();
    const today = new Date().toDateString();
    
    // Clean up message rates (older than 1 hour)
    for (const [userId, timestamps] of messageRates.entries()) {
        const recentTimestamps = timestamps.filter(ts => now - ts < 3600000);
        if (recentTimestamps.length === 0) {
            messageRates.delete(userId);
        } else {
            messageRates.set(userId, recentTimestamps);
        }
    }
    
    // Clean up daily counts (older than today)
    for (const [key] of dailyMessageCounts.entries()) {
        const [userId, date] = key.split('-');
        if (date !== today) {
            dailyMessageCounts.delete(key);
        }
    }
}

/**
 * Initialize cleanup interval
 */
function initializeCleanup() {
    // Run cleanup every hour
    setInterval(cleanupOldData, 3600000);
}

/**
 * Get filter statistics
 * @returns {Object} - Filter statistics
 */
function getFilterStats() {
    return {
        activeUsers: messageRates.size,
        dailyActiveUsers: dailyMessageCounts.size,
        totalMessages: Array.from(messageRates.values())
            .reduce((sum, timestamps) => sum + timestamps.length, 0)
    };
}

module.exports = {
    filterMessage,
    extractMessageText,
    isRateLimited,
    isDailyLimitExceeded,
    containsSpam,
    initializeCleanup,
    getFilterStats,
    cleanupOldData,
    FILTER_CONFIG
};